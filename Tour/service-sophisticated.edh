
import * 'net'

{

  namespace a'dose'to'inject (
    pi = 3.14, e = 2.72,
  ) export { # this exports all nested definitions

    # TODO demostrate access to some enclosed resources here

    method calc( m, n ) {
      ( m + e ) * n + pi
    }

  }

  # a service initialization method can be used to inject artifacts into a
  # client facing service module after it is instantiated but before running
  #
  # such a service module can actively import artifacts from other modules,
  # but to put some closure service methods there, injection is the only way

  method __peer_init__ () {
    # implant some more service method (e.g. `calc()`) to the service module

    # note contextual this/that are both the service module object for the
    # per-connection peer module initialization method, and we have access
    # to lexical outer scopes from here

    # you can do it the plain way
    that.calc = a'dose'to'inject.calc

    # or do it the fancy way
    import * a'dose'to'inject into that
  }

}

# we use a producer procedure here, so as to consume each
# connected client without the race condition to miss any one
# of them.

{
  producer serveClients( outlet, ***apk ) {

    # export the server instance so someone can import it from this module
    #
    # note @export@ adds the assigned attribute to current `this` object's
    # @__exports__@ dict at the same time it's defined into local scope
    export server = Server (
      ***apk,
      clients=outlet, # do the production of newly connected peers
    )

    # @.addrs()@ will only be populated after successful listening at os level,
    # this call waits a result before return
    case server.addrs() of {
      { addr => extraAddrs }
      -> console.info<| 'Demo service listening: ' ++ addr

      # empty @.addrs()@ means the network has failed, propagate the error
      server.join() # this usually rethrows any failure the server encountered
      # in case @.join()@ didn't throw, still report the error
      error( 'Demo service failed listening.' )
    }

  }

  method trackClientLife( peer ) {
    # wait eol of the client, catch and report any exception
    peer.join() $=> { exc } -> {
      console.warn<| 'Demo client ' ++ peer ++ ' caused some trouble: ' ++ exc
    }
    console.info<| 'Demo client disconnected - ' ++ peer
  }

  for peer from serveClients(
    'net/demo/service', # the service module
    '127.0.0.1', # local addr to bind
    3721, # local port to bind
    init=__peer_init__, # per-connection peer module initialization
  ) do {
    console.info<| 'Tracking demo client - ' ++ peer

    peer.postCommand(
      repr( `Note you are tracked, ` ++ peer ),
      # direct this command to the cli peer's conmsg channel
      conmsg
    )

    # `peer` attribute here is repeatedly changed during the loop,
    # use a separate procedure to track each peer asynchronously
    go trackClientLife( peer )
  }

  console.print( 'Server done.', result=server.eol(), )
}
