
import * 'net'

{

  # though a service module can actively import artifacts from other modules,
  # to put some service methods enclosing access to some private resource,
  # injection is the only way

  # a service initialization method can be used to inject artifacts into a
  # client facing service module after it is instantiated but before running

  # we use a namespace here to organize the artifacts going there

  namespace a'dose'to'inject (
    pi = 3.14, cntr = 0,
    # note args above are assigned to the namespace but not exported
  ) export { # export all definitions within this block

    method calc( m, n ) {

      # atomically increase our counter, with wrap back at 100
      #
      # note: `cntr` is accessed via this reference,
      #       contextual this/that here are both the namespace object
      # if we ever assigned an attribute into the local scope also named
      # `cntr`, it'll shadow the namespace's `cntr`, i.e. we'll only be able
      # to access `cntr` in the namespace via this or that reference
      ai this.cntr = case this.cntr+1 of {@
        100 -> 0 # do the wrap back
        # {@ ... @} is a scoped block, it can be used to limit the shadowing
        # i.e. assignments inside a scoped block have no effect on outside of
        # it, so even we assign (via the pattern match) to `cntr` here, the
        # formula below can still reference `cntr` in the namespace lexically
        { cntr } -> cntr
      @}

      # note: `pi` and `cntr` are accessed lexically at outer scope (of the
      #       namespace), i.e. enclosed by this method procedure
      n + m * cntr / pi
    }

  }

}

# we use a producer procedure here, so as to consume each
# connected client without the race condition to miss any one
# of them.

{
  producer serveClients( outlet, ***apk ) {

    # export the server instance so someone can import it from this module
    #
    # note @export@ adds the assigned attribute to current `this` object's
    # @__exports__@ dict at the same time it's defined into local scope
    export server = Server (
      ***apk,
      clients=outlet, # do the production of newly connected peers
    )

    # @.addrs()@ will only be populated after successful listening at os level,
    # this call waits a result before return
    case server.addrs() of {
      { addr :> extraAddrs }
      -> console.info<| 'Demo service listening: ' ++ addr

      # empty @.addrs()@ means the network has failed, propagate the error
      server.join() # this usually rethrows any failure the server encountered
      # in case @.join()@ didn't throw, still report the error
      error( 'Demo service failed listening.' )
    }

  }

  method trackClientLife( peer ) {
    # wait eol of the client, catch and report any exception
    peer.join() $=> { exc } -> {
      console.warn<| 'Demo client ' ++ peer ++ ' caused some trouble: ' ++ exc
    }
    console.info<| 'Demo client disconnected - ' ++ peer
  }

  for peer from serveClients(
    'net/demo/service', # the service module
    '127.0.0.1', # local addr to bind
    3721, # local port to bind
    init= modu => { # per-connection peer module initialization

      # implant some more service method (e.g. `calc()`) to the service module

      # you can do it the plain way
      modu.calc = a'dose'to'inject.calc

      # or do it the fancy way
      import * a'dose'to'inject into modu

    },
  ) do {
    console.info<| 'Tracking demo client - ' ++ peer

    peer.postCommand(
      repr( `Note you are tracked, ` ++ peer ),
      # direct this command to the cli peer's conmsg channel
      conmsg
    )

    # `peer` attribute here is repeatedly changed during the loop,
    # use a separate procedure to track each peer asynchronously
    go trackClientLife( peer )
  }

  console.print( 'Server done.', result=server.eol(), )
}
