
{#
 # This is the sentinel file stand in place of a host module that
 # should have been installed by the host interpreter, which contains
 # host procedures, classes and other artifacts defined via EHI,
 # and obviously, written in the host language (i.e. Haskell)
 #
 # Execution of this module file is a sign showing that wrong Edh
 # interpreter is used to run the program.
 #}
error( 'Missing host module: ' ++ __name__ )

export {

  {##
   # A `Peer` object stands in local process as a stub for communication with
   # another site, i.e. the peer site
   #}
  class Peer {

    eol :: () -> BoolType
    {##
     # check whether this peer is at end-of-life
     # i.e. the underlying network connection has been disconnected
     #
     # `false` is returned if this peer is still alive;
     # `true` is returned if the underlying connection has disconnected normally;
     # the exception which has caused abnormal disconnection will be thrown.
     #}
    method eol() pass

    join :: () -> nil
    {##
     # wait for this peer to be stopped
     # i.e. the underlying network connection get disconnected
     #
     # `nil` is returned until this peer is stopped from another thread;
     # the exception which has caused abnormal disconnection will be thrown.
     #}
    method join() pass

    stop :: () -> nil
    {##
     # stop this peer
     # i.e. disconnect the underlying network connection if it is still connected
     #
     # `true` is returned if this peer is originally alive, `false` otherwise.
     #}
    method stop() pass

    armedChannel :: ( Any ) -> SinkType || nil
    {##
     # obtain the channel sink armed to this peer, by the specified locator
     #
     # `nil` is returned when no channel has been armed with the specified
     # channel locator
     #}
    method armedChannel( chLctr ) pass

    armChannel :: ( Any ) -> SinkType || nil
    {##
     # arm a new channel with the specified locator
     #
     # previously armed channel with the same locator will be replaced, the newly
     # armed channel sink is returned
     #}
    method armChannel( chLctr, chSink= sink ) pass


    readSource :: () -> StringType
    {##
     # read a subsequent command from the peer site in source form
     #}
    method readSource() pass

    readCommand :: () -> StringType
    {##
     # read a subsequent command from the peer site in evaluated value form
     #
     # note that evaluating the Edh source in the caller's context is usually the
     # desired side-effect by calling this method
     #}
    method readCommand() pass

    p2c :: ( dir!Any, cmd!StringType ) -> nil
    p2c :: ( dir!Any, cmd!ExprType ) -> nil
    p2c :: ( dir!Any, cmd!BlobType ) -> nil
    {##
     # post a command to a channel at peer site
     #
     # `dir` if not `nil`, should be a channel locator value with appropriate
     # `repr` implementation, that used to construct the channel locator at
     # peer site for distribution of the command
     #
     # `cmd` is the command to be posted, in any of the following forms:
     #  * source code - usually in the host language of peer site, but can be in
     #    any other language given the peer site be using `readSource()` and
     #    interpreting the content accordingly
     #  * expression - meant to be evaluated by peer site in its host language
     #  * blob - meant to be treated by peer site as binary data, either as a
     #    chunk of binary stream, or standalone object
     #
     # note this method is equivalent to `postCommand()` with arguments flipped
     #}
    method p2c( dir= None, cmd= None ) pass

    postCommand :: ( dir!Any, cmd!StringType ) -> nil
    postCommand :: ( dir!Any, cmd!ExprType ) -> nil
    postCommand :: ( dir!Any, cmd!BlobType ) -> nil
    {##
     # post a command to a channel at peer site
     #
     # `dir` if not `nil`, should be a channel locator value with appropriate
     # `repr` implementation, that used to construct the channel locator at
     # peer site for distribution of the command
     #
     # `cmd` is the command to be posted, in any of the following forms:
     #  * source code - usually in the host language of peer site, but can be in
     #    any other language given the peer site be using `readSource()` and
     #    interpreting the content accordingly
     #  * expression - meant to be evaluated by peer site in its host language
     #  * blob - meant to be treated by peer site as binary data, either as a
     #    chunk of binary stream, or standalone object
     #
     # note this method is equivalent to `p2c()` with arguments flipped
     #}
    method postCommand( cmd, dir= None ) pass

  }

  {##
   # An `Addr` object represent a network address
   #
   # it is usually in IPv4/IPv6 format for the time being, but no such
   # assumption should be made for forward compatibility concerns
   #}
  class Addr {

    method __init__( host= '127.0.0.1', port= 0 ) pass

    host :: () -> host!StringType
    {##
     # obtain the host in string form
     #}
    method host() pass

    port :: () -> port!int!DecimalType
    {##
     # obtain the port in integral form
     #}
    method port() pass

    info :: () -> StringType
    {##
     # obtain the protocol specific descriptive information about this address
     #}
    method info() pass

  }

  {##
   # A network server listens and will serve incoming connections from clients
   #
   # One instance of the specified service module is instantiated per client
   # connection, the per-connection peer module initialization method if
   # specified, will run in each such instance's scope before the module source
   # get evaluated.
   #
   # The `Server` class specializes on TCP connections
   #}
  class Server {

    method __init__ (
      service'module'name,
      addr= '127.0.0.1', port= 3721, port'max= 3721,
      init= None,
      clients= sink,
      useSandbox= true,
    ) pass

    addrs :: () -> [ Addr ]
    {##
     # obtain network addresses the server successfuly listens on
     #
     # this method blocks until the network listening succeeded or failed, an
     # empty list is returned if failed, otherwise one or more addresses are
     # returned
     #}
    method addrs() pass

    eol :: () -> BoolType
    {##
     # check whether this server is at end-of-life, i.e. stopped
     #
     # `false` is returned if this server is still alive;
     # `true` is returned if the server has been stopped normally;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method eol() pass

    join :: () -> nil
    {##
     # wait for this server to be stopped
     #
     # `nil` is returned until this server is stopped from another thread;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method join() pass

    stop :: () -> nil
    {##
     # stop this server
     #
     # `true` is returned if this server is originally alive, `false` otherwise.
     #}
    method stop() pass

  }


  {##
   # A network server listens and will serve incoming connections from clients
   #
   # One instance of the specified service module is instantiated per client
   # connection, the per-connection peer module initialization method if
   # specified, will run in each such instance's scope before the module source
   # get evaluated.
   #
   # The `WsServer` class specializes on WebSocket connections
   #}
  class WsServer {

    method __init__ (
      service'module'name,
      addr= '127.0.0.1', port= 3721, port'max= 3721,
      init= None,
      clients= sink,
      useSandbox= true,
    ) pass

    addrs :: () -> [ Addr ]
    {##
     # obtain network addresses the server successfuly listens on
     #
     # this method blocks until the network listening succeeded or failed, an
     # empty list is returned if failed, otherwise one or more addresses are
     # returned
     #}
    method addrs() pass

    eol :: () -> BoolType
    {##
     # check whether this server is at end-of-life, i.e. stopped
     #
     # `false` is returned if this server is still alive;
     # `true` is returned if the server has been stopped normally;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method eol() pass

    join :: () -> nil
    {##
     # wait for this server to be stopped
     #
     # `nil` is returned until this server is stopped from another thread;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method join() pass

    stop :: () -> nil
    {##
     # stop this server
     #
     # `true` is returned if this server is originally alive, `false` otherwise.
     #}
    method stop() pass

  }


  {##
   # A network client connects to some service over the network and will consume
   # the service via the connection
   #
   # An instance of the specified consumer module is instantiated for the
   # connection, the per-connection peer module initialization method if
   # specified, will run in this instance's scope before the module source
   # get evaluated.
   #}
  class Client {

    method __init__ (
      consumer'module'name,
      addr= '127.0.0.1', port= 3721, port'max= 3721,
      init= None,
      clients= sink,
      useSandbox= true,
    ) pass

    addrs :: () -> [ Addr ]
    {##
     # obtain network addresses the server successfuly listens on
     #
     # this method blocks until the network listening succeeded or failed, an
     # empty list is returned if failed, otherwise one or more addresses are
     # returned
     #}
    method addrs() pass

    eol :: () -> BoolType
    {##
     # check whether this server is at end-of-life, i.e. stopped
     #
     # `false` is returned if this server is still alive;
     # `true` is returned if the server has been stopped normally;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method eol() pass

    join :: () -> nil
    {##
     # wait for this server to be stopped
     #
     # `nil` is returned until this server is stopped from another thread;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method join() pass

    stop :: () -> nil
    {##
     # stop this server
     #
     # `true` is returned if this server is originally alive, `false` otherwise.
     #}
    method stop() pass

  }


}
