
{#
 # This is the sentinel file stand in place of a host module that
 # should have been installed by the host interpreter, which contains
 # host procedures, classes and other artifacts defined via EHI,
 # and obviously, written in the host language (i.e. Haskell)
 #
 # Execution of this module file is a sign showing that wrong Edh
 # interpreter is used to run the program.
 #}
error( 'Missing host module: ' ++ __name__ )

export {

  {##
   # A `Peer` object stands in local process as a stub for communication with
   # another site, i.e. the peer site
   #}
  class Peer {

    eol :: () -> BoolType
    {##
     # check whether this peer is at end-of-life
     # i.e. the underlying network connection has been disconnected
     #
     # `false` is returned if this peer is still alive;
     # `true` is returned if the underlying connection has disconnected normally;
     # the exception which has caused abnormal disconnection will be thrown.
     #}
    method eol() pass

    join :: () -> nil
    {##
     # wait for this peer to be stopped
     # i.e. the underlying network connection get disconnected
     #
     # `nil` is returned until this peer is stopped from another thread;
     # the exception which has caused abnormal disconnection will be thrown.
     #}
    method join() pass

    stop :: () -> nil
    {##
     # stop this peer
     # i.e. disconnect the underlying network connection if it is still connected
     #
     # `true` is returned if this peer is originally alive, `false` otherwise.
     #}
    method stop() pass

    armedChannel :: ( Any ) -> SinkType || nil
    {##
     # obtain the channel sink armed to this peer, by the specified locator
     #
     # `nil` is returned when no channel has been armed with the specified
     # channel locator
     #}
    method armedChannel( chLctr ) pass

    armChannel :: ( Any ) -> SinkType || nil
    {##
     # arm a new channel with the specified locator
     #
     # previously armed channel with the same locator will be replaced, the newly
     # armed channel sink is returned
     #}
    method armChannel( chLctr, chSink= sink ) pass


    readSource :: () -> StringType
    {##
     # read a subsequent command from the peer site in source form
     #}
    method readSource() pass

    readCommand :: () -> StringType
    {##
     # read a subsequent command from the peer site in evaluated value form
     #
     # note that evaluating the Edh source in the caller's context is usually the
     # desired side-effect by calling this method
     #}
    method readCommand() pass

    p2c :: ( dir!Any, cmd!StringType ) -> nil
    p2c :: ( dir!Any, cmd!ExprType ) -> nil
    p2c :: ( dir!Any, cmd!BlobType ) -> nil
    {##
     # post a command to a channel at peer site
     #
     # `dir` if not `nil`, should be a channel locator value with appropriate
     # `repr` implementation, that used to construct the channel locator at
     # peer site for distribution of the command
     #
     # `cmd` is the command to be posted, in any of the following forms:
     #  * source code - usually in the host language of peer site, but can be in
     #    any other language given the peer site be using `readSource()` and
     #    interpreting the content accordingly
     #  * expression - meant to be evaluated by peer site in its host language
     #  * blob - meant to be treated by peer site as binary data, either as a
     #    chunk of binary stream, or standalone object
     #
     # note this method is equivalent to `postCommand()` with arguments flipped
     #}
    method p2c( dir= None, cmd= None ) pass

    postCommand :: ( dir!Any, cmd!StringType ) -> nil
    postCommand :: ( dir!Any, cmd!ExprType ) -> nil
    postCommand :: ( dir!Any, cmd!BlobType ) -> nil
    {##
     # post a command to a channel at peer site
     #
     # `dir` if not `nil`, should be a channel locator value with appropriate
     # `repr` implementation, that used to construct the channel locator at
     # peer site for distribution of the command
     #
     # `cmd` is the command to be posted, in any of the following forms:
     #  * source code - usually in the host language of peer site, but can be in
     #    any other language given the peer site be using `readSource()` and
     #    interpreting the content accordingly
     #  * expression - meant to be evaluated by peer site in its host language
     #  * blob - meant to be treated by peer site as binary data, either as a
     #    chunk of binary stream, or standalone object
     #
     # note this method is equivalent to `p2c()` with arguments flipped
     #}
    method postCommand( cmd, dir= None ) pass

  }

  {##
   # An `Addr` object represent a network address
   #
   # it is usually in IPv4/IPv6 format for the time being, but no such
   # assumption should be made for forward compatibility concerns
   #}
  class Addr {

    method __init__( host= '127.0.0.1', port= 0 ) pass

    host :: () -> host!StringType
    {##
     # obtain the host in string form
     #}
    method host() pass

    port :: () -> port!int!DecimalType
    {##
     # obtain the port in integral form
     #}
    method port() pass

    info :: () -> StringType
    {##
     # obtain the protocol specific descriptive information about this address
     #}
    method info() pass

  }

  {##
   # A network server listens and will serve incoming connections from clients
   #
   # One instance of the specified service module is instantiated per client
   # connection, the per-connection peer module initialization method if
   # specified, will run in each such instance's scope before the module source
   # get evaluated
   #
   # The following artifact(s) will be implanted into the module instance even
   # before calling the module initialization method:
```edh
peer :: Peer
```
   #
   # The `Server` class specializes on TCP connections
   #}
  class Server {

    method __init__ (
      service'module'name,
      addr= '127.0.0.1', port= 3721, port'max= None,
      init= None,
      clients= sink,
      useSandbox= true,
    ) pass

    addrs :: () -> [ Addr ]
    {##
     # obtain network addresses the server successfuly listens on
     #
     # this method blocks until the network listening succeeded or failed, an
     # empty list is returned if failed, otherwise one or more addresses are
     # returned
     #}
    method addrs() pass

    eol :: () -> BoolType
    {##
     # check whether this server is at end-of-life, i.e. stopped
     #
     # `false` is returned if this server is still alive;
     # `true` is returned if the server has been stopped normally;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method eol() pass

    join :: () -> nil
    {##
     # wait for this server to be stopped
     #
     # `nil` is returned until this server is stopped from another thread;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method join() pass

    stop :: () -> nil
    {##
     # stop this server
     #
     # `true` is returned if this server is originally alive, `false` otherwise.
     #}
    method stop() pass

  }


  {##
   # A network server listens and will serve incoming connections from clients
   #
   # One instance of the specified service module is instantiated per client
   # connection, the per-connection peer module initialization method if
   # specified, will run in each such instance's scope before the module source
   # get evaluated
   #
   # The following artifact(s) will be implanted into the module instance even
   # before calling the module initialization method:
```edh
peer :: Peer
```
   #
   # The `WsServer` class specializes on WebSocket connections
   #}
  class WsServer {

    method __init__ (
      service'module'name,
      addr= '127.0.0.1', port= 3721, port'max= None,
      init= None,
      clients= sink,
      useSandbox= true,
    ) pass

    addrs :: () -> [ Addr ]
    {##
     # obtain network addresses the server successfuly listens on
     #
     # this method blocks until the network listening succeeded or failed, an
     # empty list is returned if failed, otherwise one or more addresses are
     # returned
     #}
    method addrs() pass

    eol :: () -> BoolType
    {##
     # check whether this server is at end-of-life, i.e. stopped
     #
     # `false` is returned if this server is still alive;
     # `true` is returned if the server has been stopped normally;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method eol() pass

    join :: () -> nil
    {##
     # wait for this server to be stopped
     #
     # `nil` is returned until this server is stopped from another thread;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method join() pass

    stop :: () -> nil
    {##
     # stop this server
     #
     # `true` is returned if this server is originally alive, `false` otherwise.
     #}
    method stop() pass

  }


  {##
   # An instance of `HttpServer` serves static resources for web browsers
   #
   # A list of the name of Edh modules must be specified, those providing
   # overlaid static web resources, while a list of routing specification can
   # be optionally specified
   #
   # Currently supported routing specification format is:
```edh
routes :: example!(
  (path1!StringType, payload!BlobType, mime!StringType= "application/zip"),
  (path2!StringType, content!StringType),
  *(),
  (pathN!StringType, content!StringType, mime!StringType= "text/javascript"),
  mime!StringType= "text/plain",
)
```
   #
   # note dynamic routes are not supported for now, while in the future, the
   # routing specification may be extended to allow procedures as for dynamic
   # (possibly streaming) contents
   #}
  class HttpServer {

    method __init__ (
      resource'modules,
      addr= '127.0.0.1', port= 3780, port'max= None,
      init= None,
      routes= (),
    ) pass

    addrs :: () -> [ Addr ]
    {##
     # obtain network addresses the server successfuly listens on
     #
     # this method blocks until the network listening succeeded or failed, an
     # empty list is returned if failed, otherwise one or more addresses are
     # returned
     #}
    method addrs() pass

    eol :: () -> BoolType
    {##
     # check whether this server is at end-of-life, i.e. stopped
     #
     # `false` is returned if this server is still alive;
     # `true` is returned if the server has been stopped normally;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method eol() pass

    join :: () -> nil
    {##
     # wait for this server to be stopped
     #
     # `nil` is returned until this server is stopped from another thread;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method join() pass

    stop :: () -> nil
    {##
     # stop this server
     #
     # `true` is returned if this server is originally alive, `false` otherwise.
     #}
    method stop() pass

  }


  {##
   # A network client connects to some service over the network and will
   # consume the service via the connection
   #
   # An instance of the specified consumer module is instantiated for the
   # connection, the per-connection peer module initialization method if
   # specified, will run in this instance's scope before the module source
   # get evaluated.
   #
   # The following artifact(s) will be implanted into the module instance even
   # before calling the module initialization method:
```edh
peer :: Peer
```
   #
   # the `Client` class specializes on TCP connections
   #}
  class Client {

    method __init__ (
      consumer'module'name,
      addrSpec= '127.0.0.1', port= 3721,
      init= None,
      useSandbox= true,
    ) pass

    addrs :: () -> [ Addr ]
    {##
     # obtain network addresses the client successfuly connected to
     #
     # this method blocks until the network connection succeeded or failed, an
     # empty list is returned if failed, otherwise one or more addresses are
     # returned
     #}
    method addrs() pass

    eol :: () -> BoolType
    {##
     # check whether this client is at end-of-life, i.e. stopped
     #
     # `false` is returned if this client is still alive;
     # `true` is returned if the client has been stopped normally;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method eol() pass

    join :: () -> nil
    {##
     # wait for this client to be stopped
     #
     # `nil` is returned until this client is stopped from another thread;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method join() pass

    stop :: () -> nil
    {##
     # stop this client
     #
     # `true` is returned if this client is originally alive, `false` otherwise.
     #}
    method stop() pass

  }


  {##
   # A network sniffer sniffs network packets directed to its address(es)
   #
   # An instance of the specified module is instantiated for the sniffing, the
   # per-connection peer module initialization method if specified, will run in
   # this instance's scope before the module source get evaluated
   #
   # The following artifacts will be implanted into the module instance even
   # before calling the module initialization method:
```edh
peer :: Peer
eol :: () -> bool
sniff :: () -> Any
```
   #
   # And the following artifact(s) will be implanted into the module instance,
   # before the source code of an incoming command is evaluated:
```edh
sourceAddr :: Addr
```
   #
   # The `Sniffer` class specializes on UDP traffics
   #}
  class Sniffer {

    method __init__(
      modu,
      addr= '127.0.0.1', port= 3721,
      init= None,
    ) pass

    addrs :: () -> [ Addr ]
    {##
     # obtain network addresses the sniffer successfuly listens on
     #
     # this method blocks until the network listening succeeded or failed, an
     # empty list is returned if failed, otherwise one or more addresses are
     # returned
     #}
    method addrs() pass

    eol :: () -> BoolType
    {##
     # check whether this sniffer is at end-of-life, i.e. stopped
     #
     # `false` is returned if this sniffer is still alive;
     # `true` is returned if the sniffer has been stopped normally;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method eol() pass

    join :: () -> nil
    {##
     # wait for this sniffer to be stopped
     #
     # `nil` is returned until this sniffer is stopped from another thread;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method join() pass

    stop :: () -> nil
    {##
     # stop this sniffer
     #
     # `true` is returned if this sniffer is originally alive, `false`
     # otherwise.
     #}
    method stop() pass

  }


  {##
   # A network advertiser broadcast packets to its address(es)
   #
   # The `Advertiser` class specializes on UDP traffics
   #}
  class Advertiser {

    method __init__(
      addr= '255.255.255.255', port= 3721,
      from'addr= None,
    ) pass

    addrs :: () -> [ Addr ]
    {##
     # obtain network addresses the sniffer successfuly listens on
     #
     # this method blocks until the network listening succeeded or failed, an
     # empty list is returned if failed, otherwise one or more addresses are
     # returned
     #}
    method addrs() pass


    post :: ( cmd!StringType ) -> nil
    post :: ( cmd!ExprType ) -> nil
    {##
     # broadcast one or more commands to the network
     #
     # `cmds` are the commands to be posted, each in any of the following forms:
     #
     #  * source code - usually in the host language of peer site, but can be in
     #    any other language given the sniffer be using `readSource()` and
     #    interpreting the content accordingly
     #  * expression - meant to be evaluated by peer site in its host language
     #
     #}
    method post( *cmds ) pass


    eol :: () -> BoolType
    {##
     # check whether this sniffer is at end-of-life, i.e. stopped
     #
     # `false` is returned if this sniffer is still alive;
     # `true` is returned if the sniffer has been stopped normally;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method eol() pass

    join :: () -> nil
    {##
     # wait for this sniffer to be stopped
     #
     # `nil` is returned until this sniffer is stopped from another thread;
     # the exception which has caused abnormal stop will be thrown.
     #}
    method join() pass

    stop :: () -> nil
    {##
     # stop this sniffer
     #
     # `true` is returned if this sniffer is originally alive, `false`
     # otherwise.
     #}
    method stop() pass

  }


}
