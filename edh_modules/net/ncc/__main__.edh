
{#
 # networked console client
 #
 # this is the server-facing peer module for networked console
 #}

# count number of conout from server, make its change an event stream
# later we rely on this signal to wait response after submitted some
# cmd, before reading local stdio console again for next input, or
# we won't see the response before submitted next command, as the
# read will block `console.print()`
conOutCnt = 0
conOutSignal := sink
conOutSignal <- conOutCnt  # keep it non-empty

# by default, show peer's identity as part of the console prompt
cinArgs = pkargs(
  ps1 = '<'++peer.ident()++'> ƒê: ',
)

# land commands from the console server asynchronously, without any
# obtacle in the flow of incoming commands
go {
  # also, run net console io perceivers in this thread, so they don't
  # get blocked during reading from stdio console as by outer thread

  defer {
    console.debug<| 'No more commands from console server - ' ++ peer
  }

  # channel 0 is named `conin` by convention, commands through it are
  # interpreted as command prompt change requests from the connected
  # service for this consumer client
  perceive peer.armChannel( conin := 0 ) {
    {( ps1, ps2 )} -> {
      cinArgs = pkargs( ***cinArgs, ps1=ps1, ps2=ps2, )
    }
    { ps1 } -> {
      ;| ArgsPackType == type(ps1) -> {
        cinArgs = pkargs( ***cinArgs, ***ps1, )
      }
      cinArgs = pkargs( ***cinArgs, ps1=ps1, )
    }
  }

  # channel 1 is named `conout` by convention, commands through it are
  # directed to `console.print()`
  # CAVEAT: the outputting is hung up during reading of console commands
  perceive peer.armChannel( conout := 1 ) { conOut } -> {
    conOutSignal <- conOutCnt += 1  # increase and announce
    ;| ArgsPackType == type(conOut) -> {
      console.print( ***conOut )
    }
    console.print( conOut )
  }

  # channel 2 is named `conmsg` by convention, commands through it are
  # directed to logging at `info` level
  perceive peer.armChannel( conmsg := 2 ) { conMsg } -> {
    console.info<| conMsg
  }

  { while false == peer.eol() {
    case peer.readCommand() of {
      # TODO interpret any specially expected command here

      { cmdVal } -> {
        console.info<| 'Unexpected command from console server '
          ++ peer ++ '\n  ' ++ cmdVal
      }

      # note a command resulting in nil is normal, just pass by here
    }
  } } $=> { exc } -> {
    console.warn<| 'Error with console server - ' ++ peer
      ++ '\n' ++ exc
  }
}

# pump commands from local stdio console to the console server
while false == peer.eol() {
  case console.readSource(***cinArgs) of {
    # the local cmd we'd interpret textually
    ":quit" -> { break }

    { cmdSrc } -> {
      cntrBefore = mre(conOutSignal)
      peer.postCommand( cmdSrc )
      for cntrAfter from conOutSignal do if cntrAfter != cntrBefore then
        # got new conout (supposed to be the eval result) from server,
        # let's continue reading next cmd from local stdio console
        { break }
    }

    # note nil as cmd value is ignored here, so a nil is effectively nop
  }
}

