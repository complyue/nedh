
{#
 # this is the client-facing module for nedh demo service
 # 
 # this module is instantiated and run per client connection.
 #
 # a `{ net.Peer: peer }` object is guaranteed to have been
 # implanted by per-client host module preparation.
 #
 # none or more of other artifacts may have been implanted as well,
 # according to the per-client service module initialization method
 # (e.g. __serv_init__) specified on construction of the very
      net.Server( 'net/demo/service', ..., init=__serv_init__, )
 # instance.
 #
 # procedures available here - no matter imported, adhoc defined, or
 # implanted - can be called remotely by the peer.
 #
 #}

# this is an example of asynchronously responsive procedure to be
# called remotely
method callThePolice ( telno ) {
  console.warn<| 'Alerts ringing #tel ' ++ telno ++ ' ...'
  peer.postCommand(expr  # expr literal is the sane way,
    # to compose rpc commands.

    # assuming remote peer has a `method ack(msg) ...` procedure made
    # available, which `net/demo/cli` happens to have
    ack(

      # the interpolated `{$ telno $}` better to be in parentheses in case
      # it has complex repr, e.g. a named value - `policeTelNo := 110`
      'Police alerted via #tel ' ++ ( {$ telno $} )

    )
  )
}

console.info<| 'Serving demo client - ' ++ peer

# posting string form repr as an rpc command is not a good idea for most
# applications, but `net/demo/cli` is happy with such commands.
peer.postCommand( repr("Good day, " ++ peer) )

{ while false == peer.eol() {
  case peer.readCommand() of {
    # note nil as result cmd is ignored here
    { cmdVal } -> {
      console.debug<| 'Got cmd from ' ++ peer ++ '\n  ' ++ cmdVal

      # serving as a simple expression evaluator, post the result back
      peer.postCommand( repr(cmdVal) )
    }
  }
} } $=> { exc } -> {
  console.warn<| 'Demo client ' ++ peer ++ ' error: ' ++ exc
}

console.info<| 'Done with demo client - ' ++ peer
