
{#
 # this is the server-facing entry module for demo of a hackery
 # CLI (command line interface) service client
 #}

import ( Peer, **_ ) 'net/RT'
import * 'net/symbols'
effect import * 'net/effects'


# expose reacting procedures exported from the persistent module
import * '.'

# a Peer object should have been implanted atomically, the following
# line should have no practical effect but to hint an IDE for code
# completion etc.
peer ?:= Peer()

# define various effectful artifacts used for communication with this
# connected consumer client session, with `@netPeer` and `@dataSink` the
# minimum by convention
#
# note in assignments to symbolic attributes, semicolon before `@` is likely
# needed or the `@` may be parsed as an operator
effect {
  ; @netPeer = peer
  ; @dataSink = peer.armChannel( dataChan ?:= 'data' )
}

console.info<| 'Hacking service via ' ++ peer

# count number of conout from server, make its change an event stream
# later we rely on this signal to wait response after submitted some
# cmd, before reading local stdio console again for next input, or
# we won't see the response before submitted next command, as the
# read will block `console.print()`
conOutCnt = 0
conOutSignal := sink

# by default, show peer's identity as part of the console prompt
cinArgs = pkargs(
  ps1 = '<' ++peer.ident() ++ '> ƒê: ',
)

# land commands from the service asynchronously, without any
# obtacle in the flow of incoming commands
go {
  # also, run net console io perceivers in this thread, so they don't
  # get blocked during reading from stdio console as by outer thread

  defer {
    console.debug<| 'No more commands from the service - ' ++ peer
  }

  # channel 0 is named `conin` by convention, commands through it are
  # interpreted as command prompt change requests from the connected
  # service for this consumer client
  perceive peer.armChannel( conin := 0 ) {
    { ( ps1, ps2 ) } -> {
      cinArgs = pkargs( ***cinArgs, ps1=ps1, ps2=ps2, )
    }
    { ps1 } -> {
      ; | ArgsPackType == type( ps1 ) -> {
        cinArgs = pkargs( ***cinArgs, ***ps1, )
      }
      cinArgs = pkargs( ***cinArgs, ps1=ps1, )
    }
  }

  # channel 1 is named `conout` by convention, commands through it are
  # directed to `console.print()`
  # CAVEAT: the outputting is hung up during reading of console commands
  perceive peer.armChannel( conout := 1 ) { conOut } -> {
    conOutSignal <- conOutCnt += 1 # increase and announce
    ; | ArgsPackType == type( conOut ) -> {
      console.print( ***conOut )
    }
    console.print( conOut )
  }

  # channel 2 is named `conmsg` by convention, commands through it are
  # directed to logging at `info` level
  perceive peer.armChannel( conmsg := 2 ) { conMsg } -> {
    console.info<| conMsg
  }

  # channel 'err' is named `errChan` by convention, errors occurred on
  # one site are passed to its peer through this channel
  perceive peer.armChannel( errChan ) {
    { { PeerError: peerErr } } -> { throw peerErr }
    { peerErrMsg } -> { throw PeerError( peerErrMsg ) }
  }

  # trip a msg to our local conout, content of the msg doesn't need to
  # be very useful (yet better to be), the successful delivery of this
  # msg is a thing worth to validate in the first place. and then we are
  # waiting 1st conout cmd before starting read of local stdio console
  # (see below), so if the server does set some command prompt on
  # connection, we'll use it to read the 1st command from local stdio.
  #
  # note (+) is used in the rpc cmd for string concat, so as to
  #      universally work with peers speaking different languages (e.g.
  #      Python instead of Edh), while the more Haskellish (++) would be
  #      better used otherwise.
  peer.postCommand( expr
    "You're seen as " + peer + " at the server."
  ) # note here is posting to console server's default channel, so as
  # to be an expr cmd to be evaluated and posted back to our conout

    { while false == peer.eol() {
      case peer.readCommand() of {
        # TODO interpret any specially expected command here

        { cmdVal } -> {
          console.info<| 'Unexpected command from the service '
          ++ peer ++ '\n  ' ++ cmdVal
        }

        # note a command resulting in nil is normal, just pass by here
      }
  } } $=> { exc } -> {
    console.warn<| 'Error with the service - ' ++ peer
    ++ '\n' ++ exc
  }
}

# wait the 1st cmd to our conout, whether the server will issue one
# on connection on its own, we will post one (see above), so this
# won't dead lock
for _ from conOutSignal do { break }

# pump commands from local stdio console to the service
while false == peer.eol() {
  case console.readCommand( ***cinArgs ) of {
    batteries.quit -> { break }

    { cmdVal } -> {
      cntrBefore = mre( conOutSignal )
      peer.postCommand( cmdVal )
      for cntrAfter from conOutSignal do if cntrAfter != cntrBefore then
      # got new conout (supposed to be the eval result) from server,
      # let's continue reading next cmd from local stdio console
      { break }
    }

    # note nil as cmd value is ignored here, so a nil is effectively nop
  }
}

console.info<| 'Done with the service - ' ++ peer
