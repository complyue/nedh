
{#
 # this is the client-facing entry module for a networked console.
 #
 # this module is instantiated and run per client connection, the
 # client is disconnected once this module finished running.
 #}

import ( Peer, **_ ) 'net/RT'
import * 'net/symbols'
effect import * 'net/effects'


# a Peer object should have been implanted atomically, the following
# line should have no practical effect but to hint an IDE for code
# completion etc.
peer ?:= Peer()

console.info<| 'Console client connected - ' ++ peer


# define various effectful artifacts used for communication with this
# connected consumer client session, with `@netPeer` and `@dataSink` the
# minimum by convention
#
# note in assignments to symbolic attributes, semicolon before `@` is likely
# needed or the `@` may be parsed as an operator
effect {
  ; @netPeer = peer
  ; @dataSink = peer.armChannel( dataChan ?:= 'data' )
}


{

  # change console client's command prompt
  peer.p2c(
    0, # direct to `conin := 0` to change command prompt
    # use a tuple to change both ps1 and ps2
    # repr( ("(demo-con)Đ: ", "Đ| ") ),
    # or change ps1 only
    repr( "(demo-con)Đ: " ),
  )

  while peer.eol() is false { # this is the *Loop* in so-called REPL
    # Read+Eval (peer.readCommand) -> Print (peer.print) -> Loop

    case peer.readCommand() of {
      nil -> { # conout an empty string or the console client will
        # wait for its eval result forever
        peer.p2c(
          1, # direct to channel conout := 1
          "''",
        )
      }
      batteries.quit -> { break }
      batteries.dir -> peer.p2c(
        1, # direct to channel conout := 1
        repr( sprintDir() ),
      )
      { cmdVal } -> {
        peer.p2c(
          1, # direct to channel conout := 1
          repr( cmdVal ),
        )
        cmdVal = nil # clear it
      }
    }

  } $=> { # catch exceptions
    if false != peer.eol() then {
      break # already disconnected
    }
    { cmdExc } -> {
      # a business service may choose to pass error through `errChan` in
      # this case, but the console here merely notify the client about it
      peer.p2c(
        1, # direct to channel conout := 1
        repr( 'Recovered from error\n  exception=' ++ cmdExc ),
      )
    }
  }

} @=> {
  { exc } -> {
    console.error<| 'Disconnecting console client ' ++ peer
    ++ ' for error: ' ++ exc
  }
  console.info<| 'Disconnecting console client ' ++ peer
}
