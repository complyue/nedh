
{#
 # this is the CLI (command line interface) helper module
 #}

import * 'net'

# an example procedure can be called via rpc by peer
method ack(msg) {
  console.info<| 'You are informed by the service that:\n  '
    ++ msg
}

# a peer initialization method can be used to inject
# artifacts into a server facing peer module after it is
# instantiated but before running. such a peer module can
# obtain globally shared resources by vanilla importing, but
# for private resources prepared without global visibility,
# injection is the only way to pass them on to there.

method __peer_init__() {
  # implant the `ack()` procedure to the consumer module
  that.ack = ack
}

# here we use case-of + wild capture pattern to avoid the
# transaction imposed by assignment, that's to say:
#   client = Client ()
# won't work as the assignment transaction will prevent the
# necessary IO action to be performed during construction of
# the client instance.

export method cmdLineTo(
  addr      ='127.0.0.1',    # remote addr to connect
  port      =3721,           # remote port to connect
  consumer  ='net/demo/cli', # the peer module
  init      =__peer_init__,  # peer module initialization
  assignTo  =None,           # attr ref to assign to the caller
) {

  case Client( consumer, addr, port, init=init, ) of { client } -> {
    # assign the client instance to the caller if it requests so
    assignTo &> {
      that $ assignTo = client
    }
  }

  case client.addrs() of { addrs } ->
    console.info<| 'Connected to service at: ' ++ addrs

  client.join() $=> { exc } -> {
    console.info<| 'The service caused some trouble: ' ++ exc
  }

  console.info<| 'Disconnected from the service.'

}
