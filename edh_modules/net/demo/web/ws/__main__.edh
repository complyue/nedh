
{#
 # this is the client-facing entry module for a WebSocket endpoint.
 #
 # this module is instantiated and run per WebSocket connection, the
 # client is disconnected once this module finished running.
 #}

import ( Peer, **_ ) 'net/RT'
import * 'net/symbols'
effect import * 'net/effects'


# a Peer object should have been implanted atomically, the following
# line should have no technical effect but to hint an IDE for code
# completion etc.
peer ?= Peer()

console.info<| 'WebSocket client connected - ' ++ peer
defer {
  console.info<| 'Disconnecting ws client ' ++ peer
}

# define various effectful artifacts used for communication with this
# connected consumer client session, with `@netPeer` and `@dataSink` the
# minimum by convention
#
# note in assignments to symbolic attributes, semicolon before `@` is likely
# needed or the `@` may be parsed as an operator
effect {
  ; @netPeer = peer
  ; @dataSink = peer.armChannel( dataChan ?:= 'data' )
}


{

  while peer.eol() is false { # this is the *Loop* in so-called REPL
    # Read+Eval (peer.readCommand) -> Print (peer.print) -> Loop

    # simply echo back whatever posted to default channel
    case peer.readSource() of {@
      # note this is a scoped block, so attributes assigned within this block
      # will be discarded on leaving this block scope, not affecting the outer,
      # module scope at all.

      { srcIn } -> {
        # echo back
        peer.postCommand( srcIn )
      }

      # note a nil result is ignored here, nil can be returned from
      # `peer.readSource()` in case a command is posted to another channel
      # than the default one
    @}

  }

} $=> { exc } -> {
  console.error<| 'Exception by ws client ' ++ peer
  ++ ' error: ' ++ desc( exc )
}
