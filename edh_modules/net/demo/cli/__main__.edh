
{#
 # this is the client-facing peer module for demo of
 # CLI (command line interface) as a nedh service client
 # 
 # this module is instantiated and run per client connection.
 #
 # a `{ net.Peer: peer }` object is guaranteed to have been
 # implanted by per-connection host module preparation.
 #
 # none or more of other artifacts may have been implanted as well,
 # according to the per-connection peer module initialization method
 # (e.g. __peer_init__) specified on construction of the very
      net.Client( 'net/demo/cli', ..., init=__peer_init__, )
 # instance.
 #}

console.info<| 'Consuming service via ' ++ peer

# count number of conout from server, make its change an event stream
# later we rely on this signal to wait response after submitted some
# cmd, before reading local stdio console again for next input, or
# we won't see the response before submitted next command, as the
# read will block `console.print()`
conOutCnt = 0
conOutSignal := sink
conOutSignal <- conOutCnt  # keep it non-empty

# by default, show peer's identity as part of the console prompt
cinArgs = pkargs(
  ps1 = '<'++peer.ident()++'> ƒê: ',
)

# land commands from the service asynchronously, without any
# obtacle in the flow of incoming commands
go {
  # also, run net console io perceivers in this thread, so they don't
  # get blocked during reading from stdio console as by outer thread

  defer {
    console.debug<| 'No more commands from the service - ' ++ peer
  }

  # channel 0 is named `conin` by convention, commands through it are
  # interpreted as command prompt change requests from the connected
  # service for this consumer client
  perceive peer.armChannel( conin := 0 ) {
    {( ps1, ps2 )} -> {
      cinArgs = pkargs( ***cinArgs, ps1=ps1, ps2=ps2, )
    }
    { ps1 } -> {
      ;| ArgsPackType == type(ps1) -> {
        cinArgs = pkargs( ***cinArgs, ***ps1, )
      }
      cinArgs = pkargs( ***cinArgs, ps1=ps1, )
    }
  }

  # channel 1 is named `conout` by convention, commands through it are
  # directed to `console.print()`
  # CAVEAT: the outputting is hung up during reading of console commands
  perceive peer.armChannel( conout := 1 ) { conOut } -> {
    conOutSignal <- conOutCnt += 1  # increase and announce
    ;| ArgsPackType == type(conOut) -> {
      console.print( ***conOut )
    }
    console.print( conOut )
  }

  # channel 2 is named `conmsg` by convention, commands through it are
  # directed to logging at `info` level
  perceive peer.armChannel( conmsg := 2 ) { conMsg } -> {
    console.info<| conMsg
  }

  { while false == peer.eol() {
    case peer.readCommand() of {
      # TODO interpret any specially expected command here

      { cmdVal } -> {
        console.info<| 'Unexpected command from the service '
          ++ peer ++ '\n  ' ++ cmdVal
      }

      # note a command resulting in nil is normal, just pass by here
    }
  } } $=> { exc } -> {
    console.warn<| 'Error with the service - ' ++ peer
      ++ '\n' ++ exc
  }
}

# pump commands from local stdio console to the service
while false == peer.eol() {
  case console.readCommand(***cinArgs) of {
    batteries.quit -> { break }

    { cmdVal } -> {
      cntrBefore = mre(conOutSignal)
      peer.postCommand( cmdVal )
      for cntrAfter from conOutSignal do if cntrAfter != cntrBefore then
        # got new conout (supposed to be the eval result) from server,
        # let's continue reading next cmd from local stdio console
        { break }
    }

    # note nil as cmd value is ignored here, so a nil is effectively nop
  }
}

console.info<| 'Done with the service - ' ++ peer
